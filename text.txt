====== Лабиринт для крысы ======
{{ :projects?nolink&700 |}}
  * Платформа: Iskra JS
  * Язык программирования: Javascript
  * Тэги: Iskra JS, лабиринт, крыса, конструктор ПВХ.
===== Что это? =====
В этой статье мы расскажем вам как собрать лабиринт для вашей домашней крысы. В лабиринте находится множество дверей и даже каруселька. Лабиринт управляется через web-интерфейс и поддерживает сразу несколько подключений. 

Мы откроем доступ к управлению лабиринтом для всех желающих. Результат работы можно будет наблюдать в режиме онлайн в своем любимом браузере.
===== Что нам понадобится? =====
{{ :projects?nolink&700 |}}
  - [[amp>product/iskra-js?utm_source=proj&utm_campaign=maze&utm_medium=wiki | Iskra JS]]
  - [[amp>product/arduino-ethernet-shield?utm_source=proj&utm_campaign=maze&utm_medium=wiki | Ethernet Shield 2]]
  - [[amp>product/arduino-troyka-shield?utm_source=proj&utm_campaign=maze&utm_medium=wiki | Troyka Shield]]
  - [[amp>product/servo-fs90?utm_source=proj&utm_campaign=maze&utm_medium=wiki | Микросервопривод FS90]] 17 шт.
  - [[amp>product/structor-mega?utm_source=proj&utm_campaign=maze&utm_medium=wiki | Пластина мега (#Структор)]] 42 шт.
  - [[amp>product/structor-servo?utm_source=proj&utm_campaign=maze&utm_medium=wiki | Крепления микросерво (#Структор)]] 9 шт.
  - [[amp>product/structor-motor-line?utm_source=proj&utm_campaign=maze&utm_medium=wiki | Крепления моторов и датчиков линии (#Структор)]]
  - [[amp>product/3-wire-cable-digital-troyka?utm_source=proj&utm_campaign=maze&utm_medium=wiki | 3-проводной шлейф «мама-мама»]] 30 шт.
  - [[amp>product/pin-headers-long?utm_source=proj&utm_campaign=maze&utm_medium=wiki | Штырьковые соединители длинные (1×40)]] 3 шт.
  - [[amp>product/dc-motor-12mm?utm_source=proj&utm_campaign=maze&utm_medium=wiki | Мотор 12 мм]]
  - [[amp>product/shaft-coupler-3mm?utm_source=proj&utm_campaign=maze&utm_medium=wiki | Втулки на вал мотора]]
  - [[amp>product/patch-cord?utm_source=proj&utm_campaign=maze&utm_medium=wiki | Патч-корд витой пары]]
  - Блок питания 5 Вольт 5 Ампер
  - Большая плоская коробка
  - Прозрачная крышка
===== Как собрать? =====
  - Возьмите три пластины «мега». Две из них разрешьте так, чтобы получилось четыре пластины 13×7 шипов. Это будут стены лабиринта. Вставьте стены в третью пластину мега #структора.{{ :projects:maze:maze_build1.jpg?nolink&700 |}}
  - Сделайте в середине блока отверстие для вывода проводов.
  - С помощью двух панелей «крепление микросервопривода 3×4 шипа» и трех панелей («пластина 2×3 шипа») сделайте «домик» для микросервопривода.
  - Возьмите пластину «мега» и разрешьте ее на три части 15×5 шипов. Это будут двери лабиринта. Возьмите качалку для микросервопривода овальной формы. Вставьте её в панель #структора «крепление качалки 2×4 шипа» и прикрутите к валу сервопривода. Прикрепите дверь к креплению качалки с помощью панелей #структора 2×3 шипа
  - Готовый механизм двери разместите внутри стен лабиринта так, чтобы дверь в закрытом состоянии перекрывала проход для крысы. Для этого сделайте вырез в стене шириной чуть больше ширины двери. Провода микросервоприводов проденьте в центральное отверстие блока.
  - Сделайте 11 блоков стен и 17 дверей. Разместитке их так, чтобы крысе было интересно бегать между ними. Для удобства поставьте перемычки между блоками из оставшихся деталей #структора длиной 5–6 шипов.
  - Соберите карусельку с помощью #структора из набора «крепления моторов и датчиков линии». Установите на вал мотора втулку, а затем пластину мега.
  - Разместите лабиринт внутри большой плоской коробки. В дне коробки сделайте отверстие для проводов и мотора карусельки. 
  - Возьмите Iskra JS и установите на нее Ethernet Shield 2. Выше установите Troyka Shield.
  - С помощью 3-проводного шлейфа «мама-мама» и длинных штырьковых соединителей проложите кабели для коммутации микросевоприводов к Iskra JS.
  - Iskra JS имеет 18 выводов ШИМ, к которым можно подключить сервоприводы. Используйте Troyka Shield для подключения 3-проводных шлейфов.
  - Подключите один конец патч-корда витой пары в разъем Ethernet вашего устройства. Второй конец подключите к вашему Wi-Fi роутеру.
  - Подключите блок питания в пины 5V и GND.<WRAP center round important 60%>Не стоит пробовать питать лабиринт от USB компьютера. Подключайте USB только при включенном источнике питания!</WRAP>
  - Подключите кабель microUSB к Iskra JS и вашему компьютеру.
===== Алгоритм =====
  * Сразу после подачи питания устанавливаем Ethernet-соединение c сервером по протоколу UDP
  * Включаем подсветку диодной лентой
  * Считываем все пришедшие данные от сервера и открываем/закрываем двери
  * Если нажата кнопка, включаем карусельку
  * Повторяем UDP-запрос и его обработку каждые 3 секунды
===== Исходный код =====
  * Создайте блок управления диодной лентой
<code javascript >
//Настраиваем управляемую диодную ленту
SPI1.setup({baud:3200000, mosi:P4, sck:A4, miso:P7});
//Резервируем память для управления 25 диодами
var arr = new Uint8ClampedArray(25*3);
//заводим счетчик для радуги из цветных диодов
var pos = 0;
//задаем закон изменения цвета
function getPattern() {
  //увеличиваем счетчик на единицу
  ++pos;
  //для каждого цвета каждого диода устанавливаем цвет
  for (var i = 0; i < arr.length; i += 3) {
    arr[i  ] = ( 1 + Math.sin( (i+pos)*0.1324 ) ) * 127;
    arr[i+1] = ( 1 + Math.sin( (i+pos)*0.1654 ) ) * 127;
    arr[i+2] = ( 1 + Math.sin( (i+pos)*0.1    ) ) * 127;
  }
}
//каждые 50 миллисекунд обновляем цвет ленты
setInterval(function () {
  //вызываем функцию обновления цвета
  getPattern();
  //обновляем состояние ленты
  SPI1.send4bit(arr, 0b0001, 0b0011);
}, 50);
</code>
  * Создайте блок UDP-соединения
<code javascript >
//подключаем библиотеку 'WIZnet' для работы с Ethernet Shield 2
var eth = require("WIZnet");
//подключаем библиотеку 'net' для работы с сетью Интернет
var net = require('net');
//Настраиваем SPI2 интерфейс на Iskra JS
SPI2.setup({ mosi:B15, miso:B14, sck:B13 });
//устанавливаем соединение с Ethernet Shield по SPI
eth.connect(SPI2, P10);
//создаем функцию обработки сокет-соединений
function socketHandler (socket) {
  //каждые 3000 миллисекунд посылаем запрос на обновление состояний дверей
  setInterval( function () {
    socket.write('Get');
  }, 3000);
  //обрабатываем получение данных от сервера
  socket.on('data', function (data) {
    //разворачиваем данные в javascript объект
    var states = JSON.parse(data);
    var ptintOut = "";                          //DELETE!!!
    var ptintOutAngle = "";                     //DELETE!!!
    //для каждой двери обновляем текущие состояния
    for(var door in states) {
      doors[door].state = states[door].st;
      ptintOut += doors[door].state + '  ';     //DELETE!!!
      ptintOutAngle += doors[door].angle + ' '; //DELETE!!!
    }
    console.log(ptintOut);                      //DELETE!!!
    console.log(ptintOutAngle);                 //DELETE!!!
  });
  //обрабатываем отключение от сервера
  socket.on('close', function () {
    print('WARNING: connection closed');
  });
}

//создаем объект для обработки кнопки на плате Iskra JS
var InternetActivate = new Pin(C4);
// каждые 1000 миллисекунд опрашиваем состояние кнопки
var timerID = setInterval( function () {
  //Если кнопка нажата
  if(InternetActivate.read() === 0) {
    //получаем IP адрес для Iskra JS
    eth.setIP();
    //Если кнопка нажата, нет смысла опрашивать ее еще раз.
	//Отключаем интервал опроса кнопки
    clearTimeout(timerID);
    //создаем сокет-соединение на указанный IP адрес сервера и порт
    net.connect({host: '192.168.10.163', port: 1337}, socketHandler);
  }
}, 1000);
</code>
  * Создайте объект данных для хранения информации о состоянии сервоприводов
<code javascript >
//подключаем библиотеку 'servo' для работы с сервоприводами
var servo = require('servo');
//угол сервоприводов по умолчанию
var defaultAngle = 0;

//создаем объект для хранения информации о 17 сервоприводах.
//servo - объект для работы с сервоприводом.
//Значением undefined резервируем место в объекте
//state - текущее состояние двери ('o' - открыто, 'c' - закрыто) 
//angle - угол сервопривода в данный момент
//min - минимальный угол сервопривода. Соответствует полностью закрытой двери
//max - максимальный угол сервопривода. Соответствует полностью открытой двери
var doors = {
  d1 : {servo: undefined, state: 'o', angle: defaultAngle, min: 7, max: 50},
  d2 : {servo: undefined, state: 'o', angle: defaultAngle, min: 20, max: 60},
  d3 : {servo: undefined, state: 'o', angle: defaultAngle, min: 7, max: 50},
  d4 : {servo: undefined, state: 'o', angle: defaultAngle, min: 15, max: 50},
  d5 : {servo: undefined, state: 'o', angle: defaultAngle, min: 8, max: 60},
  d6 : {servo: undefined, state: 'o', angle: defaultAngle, min: 5, max: 50},
  d7 : {servo: undefined, state: 'o', angle: defaultAngle, min: 0, max: 50},
  d8 : {servo: undefined, state: 'o', angle: defaultAngle, min: 10, max: 50},
  d9 : {servo: undefined, state: 'o', angle: defaultAngle, min: 20, max: 70},
  d10 : {servo: undefined, state: 'o', angle: defaultAngle, min: 10, max: 50},
  d11 : {servo: undefined, state: 'o', angle: defaultAngle, min: 0, max: 50},
  d12 : {servo: undefined, state: 'o', angle: defaultAngle, min: 0, max: 50},
  d13 : {servo: undefined, state: 'o', angle: defaultAngle, min: 0, max: 60},
  d14 : {servo: undefined, state: 'o', angle: defaultAngle, min: 0, max: 50},
  d15 : {servo: undefined, state: 'o', angle: defaultAngle, min: 25, max: 90},
  d16 : {servo: undefined, state: 'o', angle: defaultAngle, min: 15, max: 75},
  d17 : {servo: undefined, state: 'o', angle: defaultAngle, min: 0, max: 50}
};

//объект в котором хранятся нормера пинов на плате для сервоприводов
var pins = {
  d1 : A0, d2 : A1, d3 : A2, d4 : A3, d5 : P0,
  d6 : P1, d7 : P2, d8 : P3, d9 : P5, d10 : P6,
  d11 : P8, d12 : P9, d13 : P11, d14 : P12,
  d15 : P13, d16 : SDA, d17 : SCL
};

//подключаем каждый сервопривод к своему объекту хранения
for(var pin in pins) {
  doors[pin].servo = servo.connect(pins[pin]);
}
</code>
  * Создайте  блок для обновления состояния сервоприводов и опроса кнопок
<code javascript>
//каждые 100 миллисекунд обновляем состояние сервоприводов и опрашиваем кнопки
setInterval( function () {
  //обрабатываем состояние сервоприводов
  //для каждой двери в массиве
  for(var door in doors) {
    //узнаем состояние, которое установили пользователи
    //если установлено состояние 'o' ("открыто")
    if(doors[door].state === 'o') {
      //если дверь открыта не полностью (угол сервопривода больше, чем нужно)
      if(doors[door].angle > doors[door].min) {
        //уменьшаем угол сервопривода
        doors[door].angle -= 2;
      }
    }
    //если установлено состояние 'с' ("закрыто")
    if(doors[door].state === 'c') {
      //если дверь закрыта не полностью (угол сервопривода меньше, чем нужно)
      if(doors[door].angle < doors[door].max) {
        //увеличиваем угол сервопривода
        doors[door].angle += 5;
      }
    }
    //изменяем управляющий сигнал на сервопривод
    doors[door].servo.write(doors[door].angle);
  }
  //Обрабатываем состояние кнопок
  //если нажата кнопка
  if(feederActivator.read() === 1) {
    //включаем кормушку на 1500 миллисекунд
    feeder.writeAtTime(1, 1500);
  }
}, 100);
</code>
  * Теперь просто объедините все блоки кода в один файл и вы получите готовый скрипт для работы лабиринта. Не забудьте перенести функции ''require()'' в начало вашего скрипта.
<code javascript maze_iskra.js>
//подключаем библиотеку 'WIZnet' для работы с Ethernet Shield 2
var eth = require("WIZnet");
//подключаем библиотеку 'net' для работы с сетью Интернет
var net = require('net');
//подключаем библиотеку 'servo' для работы с сервоприводами
var servo = require('servo');

//Настраиваем управляемую диодную ленту
SPI1.setup({baud:3200000, mosi:P4, sck:A4, miso:P7});
//Резервируем память для управления 25 диодами
var arr = new Uint8ClampedArray(25*3);
//заводим счетчик для радуги из цветных диодов
var pos = 0;
//задаем закон изменения цвета
function getPattern() {
  //увеличиваем счетчик на единицу
  ++pos;
  //для каждого цвета каждого диода устанавливаем цвет
  for (var i = 0; i < arr.length; i += 3) {
    arr[i  ] = ( 1 + Math.sin( (i+pos)*0.1324 ) ) * 127;
    arr[i+1] = ( 1 + Math.sin( (i+pos)*0.1654 ) ) * 127;
    arr[i+2] = ( 1 + Math.sin( (i+pos)*0.1    ) ) * 127;
  }
}

function onTimer() {
  //вызываем функцию обновления цвета
  getPattern();
  //обновляем состояние ленты
  SPI1.send4bit(arr, 0b0001, 0b0011);
}
//каждые 50 миллисекунд обновляем цвет ленты
setInterval(onTimer, 50);

//Настраиваем SPI2 интерфейс на Iskra JS
SPI2.setup({ mosi:B15, miso:B14, sck:B13 });
//устанавливаем соединение с Ethernet Shield по SPI
eth.connect(SPI2, P10);

//угол сервоприводов по умолчанию
var defaultAngle = 0;

//создаем объект для хранения информации о 17 сервоприводах.
//servo - объект для работы с сервоприводом.
//Значением undefined резервируем место в объекте
//state - текущее состояние двери ('o' - открыто, 'c' - закрыто) 
//angle - угол сервопривода в данный момент
//min - минимальный угол сервопривода. Соответствует полностью закрытой двери
//max - максимальный угол сервопривода. Соответствует полностью открытой двери
var doors = {
  d1 : {servo: undefined, state: 'o', angle: defaultAngle, min: 7, max: 50},
  d2 : {servo: undefined, state: 'o', angle: defaultAngle, min: 20, max: 60},
  d3 : {servo: undefined, state: 'o', angle: defaultAngle, min: 7, max: 50},
  d4 : {servo: undefined, state: 'o', angle: defaultAngle, min: 15, max: 50},
  d5 : {servo: undefined, state: 'o', angle: defaultAngle, min: 8, max: 60},
  d6 : {servo: undefined, state: 'o', angle: defaultAngle, min: 5, max: 50},
  d7 : {servo: undefined, state: 'o', angle: defaultAngle, min: 0, max: 50},
  d8 : {servo: undefined, state: 'o', angle: defaultAngle, min: 10, max: 50},
  d9 : {servo: undefined, state: 'o', angle: defaultAngle, min: 20, max: 70},
  d10 : {servo: undefined, state: 'o', angle: defaultAngle, min: 10, max: 50},
  d11 : {servo: undefined, state: 'o', angle: defaultAngle, min: 0, max: 50},
  d12 : {servo: undefined, state: 'o', angle: defaultAngle, min: 0, max: 50},
  d13 : {servo: undefined, state: 'o', angle: defaultAngle, min: 0, max: 60},
  d14 : {servo: undefined, state: 'o', angle: defaultAngle, min: 0, max: 50},
  d15 : {servo: undefined, state: 'o', angle: defaultAngle, min: 25, max: 90},
  d16 : {servo: undefined, state: 'o', angle: defaultAngle, min: 15, max: 75},
  d17 : {servo: undefined, state: 'o', angle: defaultAngle, min: 0, max: 50}
};

//объект в котором хранятся нормера пинов на плате для сервоприводов
var pins = {
  d1 : A0, d2 : A1, d3 : A2, d4 : A3, d5 : P0,
  d6 : P1, d7 : P2, d8 : P3, d9 : P5, d10 : P6,
  d11 : P8, d12 : P9, d13 : P11, d14 : P12,
  d15 : P13, d16 : SDA, d17 : SCL
};

//подключаем каждый сервопривод к своему объекту хранения
for(var pin in pins) {
  doors[pin].servo = servo.connect(pins[pin]);
}
//создаем объект для управления кормушкой
var feeder = new Pin(P4);
//создаем объект для обработки кнопки
var feederActivator = new Pin(P7);

//создаем функцию обработки сокет-соединений
function socketHandler (socket) {
  //каждые 3000 миллисекунд посылаем запрос на обновление состояний дверей
  setInterval( function () {
    socket.write('Get');
  }, 3000);
  //обрабатываем получение данных от сервера
  socket.on('data', function (data) {
    //разворачиваем данные в javascript объект
    var states = JSON.parse(data);
    var ptintOut = "";                          //DELETE!!!
    var ptintOutAngle = "";                     //DELETE!!!
    //для каждой двери обновляем текущие состояния
    for(var door in states) {
      doors[door].state = states[door].st;
      ptintOut += doors[door].state + '  ';     //DELETE!!!
      ptintOutAngle += doors[door].angle + ' '; //DELETE!!!
    }
    console.log(ptintOut);                      //DELETE!!!
    console.log(ptintOutAngle);                 //DELETE!!!
  });
  //обрабатываем отключение от сервера
  socket.on('close', function () {
    print('WARNING: connection closed');
  });
}

//создаем объект для обработки кнопки на плате Iskra JS
var InternetActivate = new Pin(C4);
// каждые 1000 миллисекунд опрашиваем состояние кнопки
var timerID = setInterval( function () {
  //Если кнопка нажата
  if(InternetActivate.read() === 0) {
    //получаем IP адрес для Iskra JS
    eth.setIP();
    //Если кнопка нажата, нет смысла опрашивать ее еще раз.
	//Отключаем интервал опроса кнопки
    clearTimeout(timerID);
    //создаем сокет-соединение на указанный IP адрес сервера и порт
    net.connect({host: '192.168.10.163', port: 1337}, socketHandler);
  }
}, 1000);

//каждые 100 миллисекунд обновляем состояние сервоприводов и опрашиваем кнопки
setInterval( function () {
  //обрабатываем состояние сервоприводов
  //для каждой двери в массиве
  for(var door in doors) {
    //узнаем состояние, которое установили пользователи
    //если установлено состояние 'o' ("открыто")
    if(doors[door].state === 'o') {
      //если дверь открыта не полностью (угол сервопривода больше, чем нужно)
      if(doors[door].angle > doors[door].min) {
        //уменьшаем угол сервопривода
        doors[door].angle -= 2;
      }
    }
    //если установлено состояние 'с' ("закрыто")
    if(doors[door].state === 'c') {
      //если дверь закрыта не полностью (угол сервопривода меньше, чем нужно)
      if(doors[door].angle < doors[door].max) {
        //увеличиваем угол сервопривода
        doors[door].angle += 5;
      }
    }
    //изменяем управляющий сигнал на сервопривод
    doors[door].servo.write(doors[door].angle);
  }
  //Обрабатываем состояние кнопок
  //если нажата кнопка
  if(feederActivator.read() === 1) {
    //включаем кормушку на 1500 миллисекунд
    feeder.writeAtTime(1, 1500);
  }
}, 100);
</code>
===== Демонстрация работы устройства ======
{{youtube>uJDIse1iRNI?large}}
===== Что дальше? =====
В данном проекте можно использовать любую другую плату с выходом в интернет. Если у вас уже есть [[amp>product/iskra-js?utm_source=proj&utm_campaign=maze&utm_medium=wiki | Iskra JS]], можно добавить к ней [[amp>product/esp8266-wifi-module?utm_source=proj&utm_campaign=maze&utm_medium=wiki | Wi-Fi модуль ESP8266]] или даже [[amp>product/arduino-gprs-shield?utm_source=proj&utm_campaign=maze&utm_medium=wiki | GPRS Shield]], немного изменив скетч.
Фантазия не ограничивается дверями и каруселькой. Можно добавить любые сенсоры в форм-факторе [[amp>collection/troyka?utm_source=proj&utm_campaign=maze&utm_medium=wiki | Troyka Module]].